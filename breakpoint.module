<?php

/**
 * @file
 * Manage breakpoints and breakpoint groups for responsive designs.
 */

use \Drupal\breakpoint\Breakpoint;
use \Drupal\breakpoint\BreakpointGroup;

/**
 * Implements hook_enable().
 *
 * Import breakpoints from all enabled themes.
 */
function breakpoint_enable() {
  config_install_default_config('module', 'breakpoint');
  $themes = list_themes();
  breakpoint_themes_enabled(array_keys($themes));
}

/**
 * Implements hook_themes_enabled().
 *
 * Import breakpoints from all new enabled themes.
 *
 * @param array $theme_list
 *   An array of theme names.
 */
function breakpoint_themes_enabled($theme_list) {
  $themes = list_themes();
  foreach ($theme_list as $theme_key) {
    if ($themes[$theme_key]->status) {
      $theme_breakpoints = breakpoint_get_theme_breakpoint_list($theme_key);
      if (!empty($theme_breakpoints)) {
        $weight = 0;
        // Build a breakpoint group for each theme.
        $breakpoint_group = new BreakpointGroup();
        $breakpoint_group->id = $theme_key;
        $breakpoint_group->label = $themes[$theme_key]->info['name'];
        $breakpoint_group->sourceType = Breakpoint::SOURCE_TYPE_THEME;
        foreach ($theme_breakpoints as $name => $mediaQuery) {
          $breakpoint = new Breakpoint;
          $breakpoint->name = $name;
          $breakpoint->label = ucfirst($name);
          $breakpoint->mediaQuery = $mediaQuery;
          $breakpoint->source = $theme_key;
          $breakpoint->sourceType = Breakpoint::SOURCE_TYPE_THEME;
          $breakpoint->status = TRUE;
          $breakpoint->weight = $weight++;
          $breakpoint->save();
          $breakpoint_group->breakpoints[$breakpoint->id()] = $breakpoint;
        }
        $breakpoint_group->save();

        $uri = $breakpoint_group->uri();
        if ($uri) {
          $uri_options = $uri;
          unset($uri_options['path']);
          $uri = $uri['path'];
        }
        $message = t('The breakpoints from theme %theme are imported.', array(
          '%theme' => check_plain($themes[$theme_key]->info['name']),
        ));
        if (module_exists('breakpoint_ui') && $uri) {
          $message .= '<p>' . l(t('A new breakpoint group is created for theme %theme.', array(
            '%theme' => check_plain($themes[$theme_key]->info['name']),
          )), $uri, $uri_options);
        }
        drupal_set_message($message, 'status');
      }
    }
  }
}

/**
 * Implements hook_themes_disabled().
 *
 * Remove breakpoints from all disabled themes.
 *
 * @param array $theme_list
 *   An array of theme names.
 */
function breakpoint_themes_disabled($theme_list) {
  $breakpoint_groups = entity_load_multiple('breakpoint_group', $theme_list);
  foreach ($breakpoint_groups as $breakpoint_group) {
    $breakpoint_group->delete();
    // delete all breakpoints defined by this theme.
    $names = drupal_container()->get('config.storage')->listAll('breakpoints.breakpoint.' . Breakpoint::SOURCE_TYPE_THEME . '.' . $breakpoint_group->id() . '.');
    $entity_info = entity_get_info('breakpoint');

    foreach ($names as &$name) {
      $name = substr($name, strlen($entity_info['config prefix']) + 1);
    }
    $breakpoints = entity_load_multiple('breakpoint', $names);

    foreach ($breakpoints as $breakpoint) {
      $breakpoint->delete();
    }
  }
}

/**
 * Load general settings.
 */
function breakpoint_settings() {
  $config = config('breakpoint');
  if ($config->isNew()) {
    return FALSE;
  }
  return (object)$config->get();
}

/**
 * Save multipliers to settings.
 *
 * @param array $multipliers
 *   array containing multipliers.
 */
function breakpoint_settings_save_multipliers($multipliers) {
  $config = config('breakpoint');
  $config->set('multipliers', $multipliers);
  $config->save();
}

/**
 * Reload breakpoint groups as they were defined in the theme.
 *
 * @param string $theme_key
 *   The name of the theme.
 *
 * @return BreakpointGroup
 *   Returns a BreakpointGroup containing the breakpoints defined by the theme.
 */
function breakpoint_group_reload_from_theme($theme_key) {
  // Clear caches so theme info is fresh.
  system_rebuild_theme_data();
  drupal_theme_rebuild();

  $themes = list_themes();
  if ($themes[$theme_key]->status) {
    $theme_breakpoints = breakpoint_get_theme_breakpoint_list($theme_key);
    if (!empty($theme_breakpoints)) {
      $weight = 0;
      // Build a group for the theme.
      $breakpoint_group = new BreakpointGroup();
      $breakpoint_group->id = $theme_key;
      $breakpoint_group->label = $themes[$theme_key]->info['name'];
      $breakpoint_group->sourceType = Breakpoint::SOURCE_TYPE_THEME;
      foreach ($theme_breakpoints as $name => $mediaQuery) {
        $breakpoint = new Breakpoint;
        $breakpoint->name = $name;
        $breakpoint->label = ucfirst($name);
        $breakpoint->mediaQuery = $mediaQuery;
        $breakpoint->source = $theme_key;
        $breakpoint->sourceType = Breakpoint::SOURCE_TYPE_THEME;
        $breakpoint->status = TRUE;
        $breakpoint->weight = $weight++;
        $breakpoint->save();
        $breakpoint_group->breakpoints[$breakpoint->getConfigName()] = $breakpoint;
      }
    }
    return $breakpoint_group;
  }
  return FALSE;
}

/**
 * Get a list of available breakpoints from a specified theme.
 *
 * @param $theme_key
 *   The name of the theme.
 *
 * @return
 *   An array of breakpoints in the form $breakpoint['name'] = 'media query'.
 */
function breakpoint_get_theme_breakpoint_list($theme_key) {
  $themes = list_themes();
  if (!isset($themes[$theme_key])) {
    return array();
  }

  $config = config($theme_key . '.breakpoints');
  if ($config) {
    return $config->get();
  }
  return array();
}

/**
 * Implements hook_entity_info().
 */
function breakpoint_entity_info() {
  // Breakpoint.
  $types['breakpoint'] = array(
    'label' => 'Breakpoint',
    'entity class' => 'Drupal\breakpoint\Breakpoint',
    'controller class' => 'Drupal\Core\Config\Entity\ConfigStorageController',
    'config prefix' => 'breakpoint.breakpoint',
    'entity keys' => array(
      'id' => 'id',
      'label' => 'label',
      'uuid' => 'uuid',
    ),
  );

  // Breakpoint group.
  $types['breakpoint_group'] = array(
    'label' => 'Breakpoint group',
    'entity class' => 'Drupal\breakpoint\BreakpointGroup',
    'controller class' => 'Drupal\breakpoint\BreakpointGroupController',
    'config prefix' => 'breakpoint.breakpoint_group',
    'entity keys' => array(
      'id' => 'id',
      'label' => 'label',
      'uuid' => 'uuid',
    ),
  );

  return $types;
}

/**
 * Load one breakpoint group by its identifier.
 *
 * @param int $id
 *   The id of the breakpoint group to load.
 *
 * @return Drupal\Core\Entity\EntityInterface
 *   The entity object, or FALSE if there is no entity with the given id.
 */
function breakpoint_group_load($id) {
  return entity_load('breakpoint_group', $id);
}

/**
 * Load all breakpoint groups.
 *
 * @return array
 *   An array of entity objects indexed by their ids.
 */
function breakpoint_group_load_all() {
  $breakpoint_groups = entity_load_multiple('breakpoint_group');
  return $breakpoint_groups;
}

/**
 * Load one breakpoint by its identifier.
 *
 * @param int $id
 *   The id of the breakpoint to load.
 *
 * @return Drupal\Core\Entity\EntityInterface
 *   The entity object, or FALSE if there is no entity with the given id.
 */
function breakpoint_load($id) {
  return entity_load('breakpoint', $id);
}

/**
 * Load all breakpoints.
 *
 * @return array
 *   An array of entity objects indexed by their ids.
 */
function breakpoint_load_all() {
  $breakpoints = entity_load_multiple('breakpoint');
  return $breakpoints;
}

/**
 * Load all breakpoint groups as select options.
 */
function breakpoint_group_select_options() {
  $options = array();
  $breakpoint_groups = breakpoint_group_load_all();
  foreach ($breakpoint_groups as $breakpoint_group) {
    $options[$breakpoint_group->id()] = $breakpoint_group->label();
  }
  return $options;
}
